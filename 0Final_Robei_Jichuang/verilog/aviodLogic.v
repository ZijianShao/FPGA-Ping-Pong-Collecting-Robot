module aviodLogic(
	I_clk,
	I_rst_n,
	I_barrier,
	state,
	I_turn_left,
	I_turn_right);

	//---Ports declearation: generated by Robei---
	input I_clk;
	input I_rst_n;
	input I_barrier;
	input I_turn_left;
	input I_turn_right;
	output [1:0] state;

	wire I_clk;
	wire I_rst_n;
	wire I_barrier;
	wire I_turn_left;
	wire I_turn_right;
	reg [1:0] state=2'b00;
	wire [1:0] lr;
	//----Code starts here: integrated by Robei-----
	//reg [3:0]Logic_state;//状态机
	reg [3:0]Logic_state;//状态机避障模块控制
	reg [3:0]Logic_state2;//状态机视觉转弯控制是该模块中自用的变量
	reg	Tim_rst_n;
	
	assign lr={I_turn_left,I_turn_right};
	
	always@(posedge I_clk,negedge I_rst_n)
	begin
		
		if(!I_rst_n)
		begin
			Logic_state<=4'd0;
			Logic_state2<=4'd0;
			state<=2'd0;
			Tim_rst_n<=1;
		end
		else
			begin
			if(I_barrier)
			begin

				case(Logic_state2)
						4'd0:
						begin
							case(lr)
								2'b00:
								begin
									state<=2'b01;//停止
									Logic_state2<=Logic_state2+4'd1;
								end
								2'b01:
								begin
									state<=2'b11;//右转
									Logic_state2<=Logic_state2+4'd1;
								end
								2'b10:
								begin
									state<=2'b10;//左转
									Logic_state2<=Logic_state2+4'd1;
								end
								2'b11:
								begin
									state<=2'b00;//前进
									Logic_state2<=Logic_state2+4'd1;
								end
								default: state<=2'b01;//停止
							endcase

						end
						
						4'd1:
						begin//等待转弯结束
							Tim_rst_n<=1;
							if(Tim_done)//转弯结束
							begin
								Logic_state2<=4'd0;	
							end
							else
							begin
								Logic_state2<=Logic_state2;
							end
						end
				endcase
				end
				
				
				else
					begin
					
					case(Logic_state2)
					
						4'd0:
						begin
							
						state<=2'b10;//左转
						Logic_state2<=Logic_state2+4'd1;
						
						end
						4'd1:
						begin//等待转弯结束
							Tim_rst_n<=1;
							if(Tim_done)//转弯结束
							begin
								Logic_state2<=4'd0;	
							end
							else
							begin
								Logic_state2<=Logic_state2;
							end
						end
					endcase
					
					end
				
				
				
		
			end

		
	end
	
	
	
	
	
	
	//定时器模块
	reg [31:0] tim_ctr;
	
	parameter TIME_SET=300000;//设定时间
	reg Tim_done;
	always@(posedge I_clk,negedge Tim_rst_n)
	begin
		if(!Tim_rst_n)
	begin
					tim_ctr<=32'd0;
					Tim_done<=0;
	end
	else
	begin
				if(tim_ctr==TIME_SET)	begin
					tim_ctr<=32'd0;
	Tim_done<=1;
	end
	else	begin
	tim_ctr<=tim_ctr+32'd1;
	Tim_done<=0;
	end
	end
	end
	
	
	
endmodule    //aviodLogic

/*
always@(posedge I_clk,negedge I_rst_n)
	begin
		
		if(!I_rst_n)
		begin
			Logic_state<=4'd0;
			Logic_state2<=4'd0;
			state<=2'd0;
			Tim_rst_n<=1;
		end
		else
			begin

				case(Logic_state2)
						4'd0:
						begin
							case(lr)
								2'b00:
								begin
									state<=2'b01;//停止
									Logic_state2<=Logic_state2+4'd1;
								end
								2'b01:
								begin
									state<=2'b11;//右转
									Logic_state2<=Logic_state2+4'd1;
								end
								2'b10:
								begin
									state<=2'b10;//左转
									Logic_state2<=Logic_state2+4'd1;
								end
								2'b11:
								begin
									state<=2'b00;//前进
									Logic_state2<=Logic_state2+4'd1;
								end
								default: state<=2'b01;//停止
							endcase

						end
						
						4'd1:
						begin//等待转弯结束
							Tim_rst_n<=1;
							if(Tim_done)//转弯结束
							begin
								Logic_state2<=4'd0;	
							end
							else
							begin
								Logic_state2<=Logic_state2;
							end
						end
				endcase
			end

		
	end
	*/