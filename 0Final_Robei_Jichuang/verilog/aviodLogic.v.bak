module aviodLogic(
	I_clk,
	I_rst_n,
	I_barrier,
	state);

	//---Ports declearation: generated by Robei---
	input I_clk;
	input I_rst_n;
	input I_barrier;
	output [1:0] state;

	wire I_clk;
	wire I_rst_n;
	wire I_barrier;
	reg [1:0] state;

	//----Code starts here: integrated by Robei-----
	reg [3:0]Logic_state;//状态机
	reg	Tim_rst_n;
	always@(posedge I_clk,negedge I_rst_n)
	begin
					if(!I_rst_n)
	begin
					Logic_state<=4'd0;
					state<=2'd0;
					Tim_rst_n<=1;
	end
	else
	begin
					case(Logic_state)
	4'd0:begin
						if(I_barrier)//没有障碍物
											begin
																		state<=2'd0;//继续前进
																		Logic_state<=Logic_state;
											end
						else//有障碍物
																		state<=2'd2;//左转
																		Logic_state<=Logic_state+4'd1;
																		//定时器开始计数
														Tim_rst_n<=0;//定时器初始化
						end
	4'd1:begin//等待转弯结束
						Tim_rst_n<=1;
						if(Tim_done)//转弯结束
							begin
									if(I_barrier)//没有障碍物
											begin
													Logic_state<=4'd0;
											end
									else
									begin//左边也有障碍物
											state<=2'd3;//进行右转
											Logic_state<=Logic_state+4'd1;
											Tim_rst_n<=0;//定时器初始化
									end
							end
						else
						Logic_state<=Logic_state;
						end
	4'd2:begin//等待转弯结束
						Tim_rst_n<=1;
						if(Tim_done)//回正
							Logic_state<=Logic_state+4'd1;
						else
						Logic_state<=Logic_state;
						end
	4'd3:begin//等待转弯结束
						if(Tim_done)//转弯结束
							Logic_state<=4'd0;
						else
						Logic_state<=Logic_state;
						end
	
	
	
					endcase
	end
	end
	
	//定时器模块
	reg [31:0] tim_ctr;
	
	parameter TIME_SET=120000000;//设定时间
	reg Tim_done;
	always@(posedge I_clk,negedge Tim_rst_n)
	begin
		if(!Tim_rst_n)
	begin
					tim_ctr<=32'd0;
					Tim_done<=0;
	end
	else
	begin
				if(tim_ctr==TIME_SET)	begin
					tim_ctr<=32'd0;
	Tim_done<=1;
	end
	else	begin
	tim_ctr<=tim_ctr+32'd1;
	Tim_done<=0;
	end
	end
	end
	
	
	
endmodule    //aviodLogic

